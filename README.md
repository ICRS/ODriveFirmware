# ODriveFirmware USB

## Background
Attempt to make USB Serial work on ODrive. The code for the driver was generated by STM32CubeMX, 
but seems to be buggy and need some fixes... Our current goal is to modify the firmware so that it 
is detected by Linux and implement a way for real-time communication between ODrive and a Linux machine.
Particularly, we are trying to implement a USB CDC device communication.

A small doc that might be of use for background understanding is
https://docs.google.com/document/d/1EUOU7MriOz8gpaRK3PNFTwBkXGmMQMcZYiMFauK-9UU/edit?usp=sharing


## Status
Device detected by Linux kernel (4.4.14) but not autolisted under `/dev`. 
Note the lab machines donâ€™t detect the device - old kernel version. A sample from the kind of output
we get is 

```
[346221.900229] usb 1-1: new full-speed USB device number 75 using xhci_hcd
[346222.259132] usb 1-1: new full-speed USB device number 76 using xhci_hcd
```


## Usage
Make sure you have your environment set up by installing `gcc-arm-none-eabi` and `openocd` 
(some instructions how to do that in the official ODriveFirmware https://github.com/madcowswe/ODriveFirmware 
- be careful with `gcc-arm-none-eabi`)


To load the code on the board:

1. Make sure the board is powered only by the STM programmer
2. Open a terminal and execute

```
sudo openocd -c gdb_port 3333 -c telnet_port 4444 -f interface/stlink-v2.cfg -f target/stm32f4x.cfg
```

3. Open another terminal and from the project folder execute

```
arm-none-eabi-gdb -ix .gdbinit build/ODriveFirmware.elf
```


4. Ideally you should see the program being loaded and automatically started

5. To include a breakpoint edit the file `.gdbinit` in the project folder.
Note that after program starts executing you can call `printf()` from the gdb
console and print the values of variables.

6. To continue after a breakpoint use `c` just as all standard gdb commands 

7. To check if the device was connected properly execute:

```
sudo dmesg | tail
```

Successful output should look sth like:

```
usb 7-1: new full speed USB device using uhci_hcd and address 1
usb 7-1: configuration #1 chosen from 1 choice
cdc_acm 7-1:1.0: This device cannot do calls on its own. It is not a modem.
cdc_acm 7-1:1.0: ttyACM0: USB ACM device

```

If it was unsuccessful, you would see only the first line


If it was successful you should alse see the device as output from `lsusb`



8. If you want to modify the main code being executed start from `Src/freertos.c`

```
/* StartDefaultTask function */
void StartDefaultTask(void const * argument)
{
  /* init code for USB_DEVICE */
  MX_USB_DEVICE_Init();

  /* USER CODE BEGIN StartDefaultTask */
  // Init motor control
  init_motor_control();

  // Start motor threads

  // osThreadCreate(osThread(task_motor_0), &motors[0]);
  // osThreadCreate(osThread(task_motor_1), &motors[1]);

  osThreadCreate(osThread(task_usb_cdc), NULL);


  //If we get to here, then the default task is done.
  vTaskDelete(defaultTaskHandle);

  /* USER CODE END StartDefaultTask */
}
```


## Debug Ideas to test


1. Find implementation of the STM32 USB_CDC driver and replace the autogenerated code.
A good library might be 
http://vedder.se/2012/07/usb-serial-on-stm32f4/
or
https://stm32f4-discovery.net/2014/08/library-24-virtual-com-port-vcp-stm32f4xx/
or
https://github.com/das-labor/legacy/tree/master/microcontroller/src-stm32f4xx/serialUSB

2. Play with the usb device descriptors in `Src/usbd_desc.c`. The section of the code is

```
/* USB Standard Device Descriptor */
__ALIGN_BEGIN uint8_t USBD_FS_DeviceDesc[USB_LEN_DEV_DESC] __ALIGN_END =
  {
    0x12,                       /*bLength */
    USB_DESC_TYPE_DEVICE,       /*bDescriptorType*/
#if (USBD_LPM_ENABLED == 1)
    0x01,                       /*bcdUSB */ /* changed to USB version 2.01 
                                               in order to support LPM L1 suspend
                                               resume test of USBCV3.0*/
#else  
    0x00,                       /* bcdUSB */
#endif
    0x02,
    0x02,                        /*bDeviceClass*/
    0x02,                       /*bDeviceSubClass*/
    0x00,                       /*bDeviceProtocol*/
    USB_MAX_EP0_SIZE,          /*bMaxPacketSize*/
    LOBYTE(USBD_VID),           /*idVendor*/
    HIBYTE(USBD_VID),           /*idVendor*/
    LOBYTE(USBD_PID_FS),           /*idVendor*/
    HIBYTE(USBD_PID_FS),           /*idVendor*/
    0x00,                       /*bcdDevice rel. 2.00*/
    0x02,
    USBD_IDX_MFC_STR,           /*Index of manufacturer  string*/
    USBD_IDX_PRODUCT_STR,       /*Index of product string*/
    USBD_IDX_SERIAL_STR,        /*Index of serial number string*/
    USBD_MAX_NUM_CONFIGURATION  /*bNumConfigurations*/
  } ; 
```

Try finding the documention for this STM32 specific chip to see if the values are correct.
Note there might be other stuff you need to change.
Some references (unchecked):

http://www.st.com/content/ccc/resource/technical/document/user_manual/01/c6/32/df/79/ad/48/32/CD00158241.pdf/files/CD00158241.pdf/jcr:content/translations/en.CD00158241.pdf
http://www.st.com/content/ccc/resource/technical/document/reference_manual/3d/6d/5a/66/b4/99/40/d4/DM00031020.pdf/files/DM00031020.pdf/jcr:content/translations/en.DM00031020.pdf
http://www.cnblogs.com/shangdawei/p/4712376.html
http://www.chibios.com/forum/viewtopic.php?t=699

3. In `Inc/usbd_conf.h` modify the line `#define USBD_DEBUG_LEVEL     0` to enable debugging and see what the debug messages are. Might be helpful

3. Read the whole usb cdc documention and figure out what is wrong.

